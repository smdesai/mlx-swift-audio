// Checkpoint Reader for Accuracy Testing

import Foundation
import MLX

/// Reads checkpoint tensors generated by Python for accuracy comparison
enum CheckpointReader {
  /// Manifest describing all checkpoints
  struct Manifest: Codable {
    let refAudio: String
    let text: String
    let modelId: String
    let stages: [String: StageInfo]

    enum CodingKeys: String, CodingKey {
      case refAudio = "ref_audio"
      case text
      case modelId = "model_id"
      case stages
    }
  }

  struct StageInfo: Codable {
    let shape: [Int]?
    let dtype: String?
    let file: String?
    let min: Double?
    let max: Double?
    let mean: Double?
    let std: Double?
    let sampleRate: Int?
    let text: String?  // For text stages

    enum CodingKeys: String, CodingKey {
      case shape, dtype, file, min, max, mean, std
      case sampleRate = "sample_rate"
      case text
    }
  }

  /// Load manifest from checkpoint directory
  static func loadManifest(from directory: URL) throws -> Manifest {
    let manifestURL = directory.appendingPathComponent("manifest.json")
    let data = try Data(contentsOf: manifestURL)
    return try JSONDecoder().decode(Manifest.self, from: data)
  }

  /// Load a float32 tensor from binary file
  static func loadFloat32(from directory: URL, name: String, shape: [Int]) throws -> MLXArray {
    let fileURL = directory.appendingPathComponent("\(name).bin")
    let data = try Data(contentsOf: fileURL)

    let count = shape.reduce(1, *)
    guard data.count == count * MemoryLayout<Float>.size else {
      throw CheckpointError.sizeMismatch(
        expected: count * MemoryLayout<Float>.size,
        actual: data.count,
        name: name
      )
    }

    let floats = data.withUnsafeBytes { ptr -> [Float] in
      let buffer = ptr.bindMemory(to: Float.self)
      return Array(buffer)
    }

    return MLXArray(floats).reshaped(shape)
  }

  /// Load an int32 tensor from binary file
  static func loadInt32(from directory: URL, name: String, shape: [Int]) throws -> MLXArray {
    let fileURL = directory.appendingPathComponent("\(name).bin")
    let data = try Data(contentsOf: fileURL)

    let count = shape.reduce(1, *)
    guard data.count == count * MemoryLayout<Int32>.size else {
      throw CheckpointError.sizeMismatch(
        expected: count * MemoryLayout<Int32>.size,
        actual: data.count,
        name: name
      )
    }

    let ints = data.withUnsafeBytes { ptr -> [Int32] in
      let buffer = ptr.bindMemory(to: Int32.self)
      return Array(buffer)
    }

    return MLXArray(ints).reshaped(shape)
  }

  /// Load a checkpoint tensor by name
  static func load(from directory: URL, name: String, manifest: Manifest) throws -> MLXArray {
    guard let info = manifest.stages[name] else {
      throw CheckpointError.notFound(name)
    }

    guard let shape = info.shape, let dtype = info.dtype else {
      throw CheckpointError.invalidMetadata(name)
    }

    switch dtype {
    case "float32":
      return try loadFloat32(from: directory, name: name, shape: shape)
    case "int32":
      return try loadInt32(from: directory, name: name, shape: shape)
    default:
      throw CheckpointError.unsupportedDtype(dtype)
    }
  }

  enum CheckpointError: Error, CustomStringConvertible {
    case notFound(String)
    case invalidMetadata(String)
    case sizeMismatch(expected: Int, actual: Int, name: String)
    case unsupportedDtype(String)

    var description: String {
      switch self {
      case let .notFound(name):
        return "Checkpoint '\(name)' not found in manifest"
      case let .invalidMetadata(name):
        return "Invalid metadata for checkpoint '\(name)'"
      case let .sizeMismatch(expected, actual, name):
        return "Size mismatch for '\(name)': expected \(expected) bytes, got \(actual)"
      case let .unsupportedDtype(dtype):
        return "Unsupported dtype: \(dtype)"
      }
    }
  }
}

/// Tensor comparison utilities for accuracy testing
enum TensorComparison {
  /// Result of comparing two tensors
  struct ComparisonResult {
    let passed: Bool
    let maxAbsDiff: Float
    let meanAbsDiff: Float
    let maxRelDiff: Float
    let correlation: Float
    let message: String
  }

  /// Compare two tensors with tolerance
  static func compare(
    _ a: MLXArray,
    _ b: MLXArray,
    absoluteTolerance: Float = 1e-5,
    relativeTolerance: Float = 1e-4,
    name: String = "tensor"
  ) -> ComparisonResult {
    // Check shapes match
    guard a.shape == b.shape else {
      return ComparisonResult(
        passed: false,
        maxAbsDiff: .infinity,
        meanAbsDiff: .infinity,
        maxRelDiff: .infinity,
        correlation: 0,
        message: "Shape mismatch: \(a.shape) vs \(b.shape)"
      )
    }

    // Convert to float arrays
    let aFlat = a.flattened().asArray(Float.self)
    let bFlat = b.flattened().asArray(Float.self)

    // Calculate statistics
    var maxAbsDiff: Float = 0
    var sumAbsDiff: Float = 0
    var maxRelDiff: Float = 0

    for i in 0 ..< aFlat.count {
      let diff = abs(aFlat[i] - bFlat[i])
      sumAbsDiff += diff
      maxAbsDiff = max(maxAbsDiff, diff)

      let maxVal = max(abs(aFlat[i]), abs(bFlat[i]))
      if maxVal > 1e-8 {
        maxRelDiff = max(maxRelDiff, diff / maxVal)
      }
    }

    let meanAbsDiff = sumAbsDiff / Float(aFlat.count)

    // Calculate correlation
    let meanA = aFlat.reduce(0, +) / Float(aFlat.count)
    let meanB = bFlat.reduce(0, +) / Float(bFlat.count)

    var cov: Float = 0
    var varA: Float = 0
    var varB: Float = 0

    for i in 0 ..< aFlat.count {
      let da = aFlat[i] - meanA
      let db = bFlat[i] - meanB
      cov += da * db
      varA += da * da
      varB += db * db
    }

    let correlation = (varA > 0 && varB > 0) ? cov / sqrt(varA * varB) : 0

    // Determine if passed
    let passed = maxAbsDiff <= absoluteTolerance || maxRelDiff <= relativeTolerance

    let status = passed ? "✓ PASS" : "✗ FAIL"
    let message = """
      \(status): \(name)
        Shape: \(a.shape)
        Max abs diff: \(String(format: "%.6e", maxAbsDiff)) (tol: \(absoluteTolerance))
        Mean abs diff: \(String(format: "%.6e", meanAbsDiff))
        Max rel diff: \(String(format: "%.6e", maxRelDiff)) (tol: \(relativeTolerance))
        Correlation: \(String(format: "%.6f", correlation))
      """

    return ComparisonResult(
      passed: passed,
      maxAbsDiff: maxAbsDiff,
      meanAbsDiff: meanAbsDiff,
      maxRelDiff: maxRelDiff,
      correlation: correlation,
      message: message
    )
  }

  /// Compare integer tensors (exact match required)
  static func compareExact(_ a: MLXArray, _ b: MLXArray, name: String = "tensor") -> ComparisonResult {
    guard a.shape == b.shape else {
      return ComparisonResult(
        passed: false,
        maxAbsDiff: .infinity,
        meanAbsDiff: .infinity,
        maxRelDiff: .infinity,
        correlation: 0,
        message: "Shape mismatch: \(a.shape) vs \(b.shape)"
      )
    }

    let aFlat = a.flattened().asArray(Int32.self)
    let bFlat = b.flattened().asArray(Int32.self)

    var mismatches = 0
    var firstMismatchIdx = -1

    for i in 0 ..< aFlat.count {
      if aFlat[i] != bFlat[i] {
        mismatches += 1
        if firstMismatchIdx < 0 {
          firstMismatchIdx = i
        }
      }
    }

    let passed = mismatches == 0

    let status = passed ? "✓ PASS" : "✗ FAIL"
    var message = """
      \(status): \(name)
        Shape: \(a.shape)
        Mismatches: \(mismatches) / \(aFlat.count)
      """

    if !passed && firstMismatchIdx >= 0 {
      message += "\n    First mismatch at index \(firstMismatchIdx): \(aFlat[firstMismatchIdx]) vs \(bFlat[firstMismatchIdx])"
    }

    return ComparisonResult(
      passed: passed,
      maxAbsDiff: Float(mismatches),
      meanAbsDiff: Float(mismatches) / Float(aFlat.count),
      maxRelDiff: passed ? 0 : 1,
      correlation: passed ? 1 : 0,
      message: message
    )
  }

  /// Print a summary of tensor values for debugging
  static func summarize(_ tensor: MLXArray, name: String) -> String {
    let flat = tensor.flattened().asArray(Float.self)

    let minVal = flat.min() ?? 0
    let maxVal = flat.max() ?? 0
    let mean = flat.reduce(0, +) / Float(flat.count)
    let variance = flat.map { ($0 - mean) * ($0 - mean) }.reduce(0, +) / Float(flat.count)
    let std = sqrt(variance)

    return """
      \(name):
        Shape: \(tensor.shape)
        Range: [\(String(format: "%.6f", minVal)), \(String(format: "%.6f", maxVal))]
        Mean: \(String(format: "%.6f", mean)), Std: \(String(format: "%.6f", std))
        First 5: \(flat.prefix(5).map { String(format: "%.4f", $0) }.joined(separator: ", "))
        Last 5: \(flat.suffix(5).map { String(format: "%.4f", $0) }.joined(separator: ", "))
      """
  }
}
